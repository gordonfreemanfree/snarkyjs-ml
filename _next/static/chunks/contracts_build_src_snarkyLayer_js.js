"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["contracts_build_src_snarkyLayer_js"],{

/***/ "../contracts/build/src/snarkyLayer.js":
/*!*********************************************!*\
  !*** ../contracts/build/src/snarkyLayer.js ***!
  \*********************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.a(__webpack_module__, async function (__webpack_handle_async_dependencies__, __webpack_async_result__) { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SnarkyLayer1\": function() { return /* binding */ SnarkyLayer1; },\n/* harmony export */   \"SnarkyLayer2\": function() { return /* binding */ SnarkyLayer2; }\n/* harmony export */ });\n/* harmony import */ var snarkyjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! snarkyjs */ \"./node_modules/snarkyjs/dist/web/index.js\");\n/* harmony import */ var _snarkyTensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./snarkyTensor.js */ \"../contracts/build/src/snarkyTensor.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_snarkyTensor_js__WEBPACK_IMPORTED_MODULE_1__]);\n_snarkyTensor_js__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// Description: SnarkyNet and SnarkyLayers allow for the implementation of a SnarkyJS\n// version of a Deep Neural Network.\n// SnarkyLayers are defined to represent the Dense Neural Network layers combined in\n// SnarkyNet for prediction.\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\n\n\n// await isReady;\n// create a layer\nclass SnarkyLayer1 extends _snarkyTensor_js__WEBPACK_IMPORTED_MODULE_1__.SnarkyTensor {\n    constructor(weights, activation = 'relu', // default activation function\n    alpha = (0,snarkyjs__WEBPACK_IMPORTED_MODULE_0__.Field)(10) // alread scaled by 1000\n    ) {\n        super();\n        // this.scale_factor_Field = Field(10000000);\n        // Activation Function\n        this.activation = this.activation_selection(activation);\n        // Set alpha\n        // this.alpha = this.num2int65(alpha);\n        this.alpha = alpha;\n        // Weights\n        this.weights = weights;\n    }\n    // // Description:   Perform a dot product for two rank 2 tensors of type Field\n    // // Input:         m1 - Rank 2 Tensor of type Field\n    // //                m2 - Rank 2 Tensor of type Field\n    // // Output:        y - Dot product Rank 2 Tensor of type Field\n    // dot_product_t2(m1: Array<Field>[], m2: Array<Field>[]): Array<Field>[] {\n    //   console.log('in the dot product');\n    //   // Perform a dot product on the two rank 2 tensors\n    //   let y = Array();\n    //   let m2_t = this.transpose(m2);\n    //   // let m2_t = m2;\n    //   for (let i = 0; i < m1.length; i++) {\n    //     console.log('in the for loop', i);\n    //     let m_array = Array();\n    //     for (let j = 0; j < m2_t.length; j++) {\n    //       console.log('in the for loop', j);\n    //       m_array[j] = this.dot_product_t1(m1[i], m2_t[j]);\n    //     }\n    //     y[i] = m_array;\n    //   }\n    //   return y;\n    // }\n    // // Description:   Perform a dot product for two rank 1 tensors of type Field\n    // // Input:         m1 - Rank 1 Tensor of type Field\n    // //                m2 - Rank 1 Tensor of type Field\n    // // Output:        y - Dot product Rank 0 Tensor of type Field\n    // dot_product_t1(v1: Array<Field>, v2: Array<Field>): Field {\n    //   let y = Field.zero;\n    //   console.assert(\n    //     v1.length === v2.length,\n    //     \"tensor dimensions do not fit, can't do dot_product_t1\"\n    //   );\n    //   v1.forEach(\n    //     (v1_value, i) =>\n    //       // (y = y.add(v1_value.mul(v2[i]).div(this.scale_factor_Field)))\n    //       (y = y.add(v1_value.mul(v2[i])))\n    //   );\n    //   return y;\n    // }\n    // // Description:   Transpose a rank 2 tensor of type Field\n    // // Input:         x - Rank 2 Tensor of type Field\n    // // Output:        y - Transposed Rank 2 Tensor of type Field of x\n    // transpose(x: Array<Field>[]): Array<Field>[] {\n    //   // Transpose the rank 2 tensor\n    //   let y = Array();\n    //   for (let i = 0; i < x[0].length; i++) {\n    //     let m_array = Array();\n    //     for (let j = 0; j < x.length; j++) {\n    //       m_array[j] = x[j][i];\n    //     }\n    //     y[i] = m_array;\n    //   }\n    //   return y;\n    // }\n    // exp_part(x: UInt64, y: number, z: number): UInt64 {\n    //   // Portion of the Expotential Calculation\n    //   // (x^y)/z\n    //   let result = UInt64.from(x);\n    //   result = result.div(UInt64.from(z));\n    //   for (let i = 1; i < y; i++) {\n    //     result = result.mul(x).div(UInt64.from(this.scale_factor_Field));\n    //     result = result.mul(UInt64.from(x));\n    //   }\n    //   return result;\n    // }\n    // // Description:   Calculate the expotential\n    // // Input:         Rank 0 Tensor of type Field for the power\n    // // Output:        Rank 0 Tensor of type Field result of calculation\n    // exp(x: UInt64): UInt64 {\n    //   // Expotential Implementation\n    //   // 1 + x + (x^2)/2 + (x^3)/6 + (x^4)/24 + (x^5)/120 + (x^6)/720 + (x^7)/5040\n    //   // return this.num2Field(1)\n    //   return UInt64.one\n    //     .add(UInt64.from(x))\n    //     .add(this.exp_part(x, 2, 2))\n    //     .add(this.exp_part(x, 3, 6))\n    //     .add(this.exp_part(x, 4, 24))\n    //     .add(this.exp_part(x, 5, 120))\n    //     .add(this.exp_part(x, 6, 720))\n    //     .add(this.exp_part(x, 7, 5040));\n    // }\n    call(input) {\n        console.log('in the call function');\n        // Equivalent: output = activation( dot( input, weight ) )\n        return this.activation_t2(this.dot_product_t2(input, this.weights));\n    }\n    // Select Activation Function\n    activation_selection(activation) {\n        // Select the activation function\n        if (activation == 'relu') {\n            return this.relu_t1;\n        } // RelU Activation Function\n        else if (activation == 'relu_leaky') {\n            return this.relu_leaky_t1;\n        } // Leaky RelU Activation Function\n        else if (activation == 'softmax') {\n            return this.softmax_t1;\n        } // Softmax Activation Function\n        // else if (activation == 'tayler') {\n        //   return this.tayler;\n        // }\n        else {\n            throw Error('Activation Function Not Valid');\n        } // Invalid Activation Function\n    }\n    // Activation\n    activation_t2(x) {\n        console.log('in the activation_t2 function');\n        // Applying activation functions for a rank 2 tensor\n        let result = Array();\n        // x.forEach((value, index) => (result[index] = this.activation(value)));\n        x.forEach((value, index) => (result[index] = this.relu_t1(value)));\n        return result;\n    }\n    // Activation Functions (implemented for rank 1 tensors)\n    relu_t1(x) {\n        // RelU implementation for an Array\n        // Equivalent: result = max( x, 0 )\n        let result = Array();\n        x.forEach((value, i) => (result[i] = value));\n        return result;\n    }\n    relu_leaky_t1(x) {\n        // Leaky RelU implementation for an Array\n        let result = Array();\n        x.forEach((value, i) => (result[i] = value));\n        return result;\n    }\n    softmax_t1(x) {\n        // Softmax Implementation for an Array\n        console.log('in the softmax_t1 function');\n        console.log('x before exp part is', x.toString());\n        let sum = snarkyjs__WEBPACK_IMPORTED_MODULE_0__.UInt64.zero;\n        let result = Array();\n        // Equivalent: result = x / ( x1 + .. + xn )\n        console.log('x before exp part is', x.toString());\n        // preventing overflow\n        let reduced_x = Array();\n        x.forEach((value, i) => (reduced_x[i] = snarkyjs__WEBPACK_IMPORTED_MODULE_0__.UInt64.from(value).div(snarkyjs__WEBPACK_IMPORTED_MODULE_0__.UInt64.from(1000000))));\n        console.log('x after overflow prevention is', reduced_x.toString());\n        reduced_x.forEach((value) => console.log(this.exp(value).toString()));\n        console.log('x after exp is', reduced_x.toString());\n        // result returned as percentage\n        reduced_x.forEach((value) => (sum = sum.add(this.exp(value))));\n        console.log('sum is', sum.toString());\n        reduced_x.forEach((value, i) => {\n            let quotientAndRemainder = this.exp(value).divMod(sum);\n            result[i] = quotientAndRemainder.rest;\n        });\n        console.log('result is', result.toString());\n        return result;\n    }\n}\n__decorate([\n    (0,snarkyjs__WEBPACK_IMPORTED_MODULE_0__.matrixProp)(snarkyjs__WEBPACK_IMPORTED_MODULE_0__.Field, 64, 10),\n    __metadata(\"design:type\", Array)\n], SnarkyLayer1.prototype, \"weights\", void 0);\nclass SnarkyLayer2 extends _snarkyTensor_js__WEBPACK_IMPORTED_MODULE_1__.SnarkyTensor {\n    constructor(weights, activation = 'relu', // default activation function\n    alpha = (0,snarkyjs__WEBPACK_IMPORTED_MODULE_0__.Field)(10) // alread scaled by 1000\n    ) {\n        super();\n        // this.scale_factor_Field = Field(10000000);\n        // Activation Function\n        this.activation = this.activation_selection(activation);\n        // Set alpha\n        // this.alpha = this.num2int65(alpha);\n        this.alpha = alpha;\n        // Weights\n        this.weights = weights;\n    }\n    // // Description:   Perform a dot product for two rank 2 tensors of type Field\n    // // Input:         m1 - Rank 2 Tensor of type Field\n    // //                m2 - Rank 2 Tensor of type Field\n    // // Output:        y - Dot product Rank 2 Tensor of type Field\n    // dot_product_t2(m1: Array<Field>[], m2: Array<Field>[]): Array<Field>[] {\n    //   console.log('in the dot product');\n    //   // Perform a dot product on the two rank 2 tensors\n    //   let y = Array();\n    //   let m2_t = this.transpose(m2);\n    //   // let m2_t = m2;\n    //   for (let i = 0; i < m1.length; i++) {\n    //     console.log('in the for loop', i);\n    //     let m_array = Array();\n    //     for (let j = 0; j < m2_t.length; j++) {\n    //       console.log('in the for loop', j);\n    //       m_array[j] = this.dot_product_t1(m1[i], m2_t[j]);\n    //     }\n    //     y[i] = m_array;\n    //   }\n    //   return y;\n    // }\n    // // Description:   Perform a dot product for two rank 1 tensors of type Field\n    // // Input:         m1 - Rank 1 Tensor of type Field\n    // //                m2 - Rank 1 Tensor of type Field\n    // // Output:        y - Dot product Rank 0 Tensor of type Field\n    // dot_product_t1(v1: Array<Field>, v2: Array<Field>): Field {\n    //   let y = Field.zero;\n    //   console.assert(\n    //     v1.length === v2.length,\n    //     \"tensor dimensions do not fit, can't do dot_product_t1\"\n    //   );\n    //   v1.forEach(\n    //     (v1_value, i) =>\n    //       // (y = y.add(v1_value.mul(v2[i]).div(this.scale_factor_Field)))\n    //       (y = y.add(v1_value.mul(v2[i])))\n    //   );\n    //   return y;\n    // }\n    // // Description:   Transpose a rank 2 tensor of type Field\n    // // Input:         x - Rank 2 Tensor of type Field\n    // // Output:        y - Transposed Rank 2 Tensor of type Field of x\n    // transpose(x: Array<Field>[]): Array<Field>[] {\n    //   // Transpose the rank 2 tensor\n    //   let y = Array();\n    //   for (let i = 0; i < x[0].length; i++) {\n    //     let m_array = Array();\n    //     for (let j = 0; j < x.length; j++) {\n    //       m_array[j] = x[j][i];\n    //     }\n    //     y[i] = m_array;\n    //   }\n    //   return y;\n    // }\n    // exp_part(x: UInt64, y: number, z: number): UInt64 {\n    //   // Portion of the Expotential Calculation\n    //   // (x^y)/z\n    //   let result = UInt64.from(x);\n    //   result = result.div(UInt64.from(z));\n    //   for (let i = 1; i < y; i++) {\n    //     result = result.mul(x).div(UInt64.from(this.scale_factor_Field));\n    //     result = result.mul(UInt64.from(x));\n    //   }\n    //   return result;\n    // }\n    // // Description:   Calculate the expotential\n    // // Input:         Rank 0 Tensor of type Field for the power\n    // // Output:        Rank 0 Tensor of type Field result of calculation\n    // exp(x: UInt64): UInt64 {\n    //   // Expotential Implementation\n    //   // 1 + x + (x^2)/2 + (x^3)/6 + (x^4)/24 + (x^5)/120 + (x^6)/720 + (x^7)/5040\n    //   // return this.num2Field(1)\n    //   return UInt64.one\n    //     .add(UInt64.from(x))\n    //     .add(this.exp_part(x, 2, 2))\n    //     .add(this.exp_part(x, 3, 6))\n    //     .add(this.exp_part(x, 4, 24))\n    //     .add(this.exp_part(x, 5, 120))\n    //     .add(this.exp_part(x, 6, 720))\n    //     .add(this.exp_part(x, 7, 5040));\n    // }\n    call(input) {\n        console.log('in the call function');\n        // Equivalent: output = activation( dot( input, weight ) )\n        return this.activation_t2(this.dot_product_t2(input, this.weights));\n    }\n    // Select Activation Function\n    activation_selection(activation) {\n        // Select the activation function\n        if (activation == 'relu') {\n            return this.relu_t1;\n        } // RelU Activation Function\n        else if (activation == 'relu_leaky') {\n            return this.relu_leaky_t1;\n        } // Leaky RelU Activation Function\n        else if (activation == 'softmax') {\n            return this.softmax_t1;\n        } // Softmax Activation Function\n        // else if (activation == 'tayler') {\n        //   return this.tayler;\n        // }\n        else {\n            throw Error('Activation Function Not Valid');\n        } // Invalid Activation Function\n    }\n    // Activation\n    activation_t2(x) {\n        console.log('in the activation_t2 function');\n        // Applying activation functions for a rank 2 tensor\n        let result = Array();\n        // x.forEach((value, index) => (result[index] = this.activation(value)));\n        x.forEach((value, index) => (result[index] = this.relu_t1(value)));\n        return result;\n    }\n    // Activation Functions (implemented for rank 1 tensors)\n    relu_t1(x) {\n        // RelU implementation for an Array\n        // Equivalent: result = max( x, 0 )\n        let result = Array();\n        x.forEach((value, i) => (result[i] = value));\n        return result;\n    }\n    relu_leaky_t1(x) {\n        // Leaky RelU implementation for an Array\n        let result = Array();\n        x.forEach((value, i) => (result[i] = value));\n        return result;\n    }\n    softmax_t1(x) {\n        // Softmax Implementation for an Array\n        console.log('in the softmax_t1 function');\n        console.log('x before exp part is', x.toString());\n        let sum = snarkyjs__WEBPACK_IMPORTED_MODULE_0__.UInt64.zero;\n        let result = Array();\n        // Equivalent: result = x / ( x1 + .. + xn )\n        console.log('x before exp part is', x.toString());\n        // preventing overflow\n        let reduced_x = Array();\n        x.forEach((value, i) => (reduced_x[i] = snarkyjs__WEBPACK_IMPORTED_MODULE_0__.UInt64.from(value).div(snarkyjs__WEBPACK_IMPORTED_MODULE_0__.UInt64.from(1000000))));\n        console.log('x after overflow prevention is', reduced_x.toString());\n        reduced_x.forEach((value) => console.log(this.exp(value).toString()));\n        console.log('x after exp is', reduced_x.toString());\n        // result returned as percentage\n        reduced_x.forEach((value) => (sum = sum.add(this.exp(value))));\n        console.log('sum is', sum.toString());\n        reduced_x.forEach((value, i) => {\n            let quotientAndRemainder = this.exp(value).divMod(sum);\n            result[i] = quotientAndRemainder.rest;\n        });\n        console.log('result is', result.toString());\n        return result;\n    }\n}\n__decorate([\n    (0,snarkyjs__WEBPACK_IMPORTED_MODULE_0__.matrixProp)(snarkyjs__WEBPACK_IMPORTED_MODULE_0__.Field, 10, 10),\n    __metadata(\"design:type\", Array)\n], SnarkyLayer2.prototype, \"weights\", void 0);\n//# sourceMappingURL=snarkyLayer.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpREFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlEQUFXLFlBQVksaURBQVc7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9EQUFVLENBQUMsMkNBQUs7QUFDcEI7QUFDQTtBQUNBLHVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb250cmFjdHMvYnVpbGQvc3JjL3NuYXJreUxheWVyLmpzPzA3ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRGVzY3JpcHRpb246IFNuYXJreU5ldCBhbmQgU25hcmt5TGF5ZXJzIGFsbG93IGZvciB0aGUgaW1wbGVtZW50YXRpb24gb2YgYSBTbmFya3lKU1xuLy8gdmVyc2lvbiBvZiBhIERlZXAgTmV1cmFsIE5ldHdvcmsuXG4vLyBTbmFya3lMYXllcnMgYXJlIGRlZmluZWQgdG8gcmVwcmVzZW50IHRoZSBEZW5zZSBOZXVyYWwgTmV0d29yayBsYXllcnMgY29tYmluZWQgaW5cbi8vIFNuYXJreU5ldCBmb3IgcHJlZGljdGlvbi5cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5leHBvcnQgeyBTbmFya3lMYXllcjEsIFNuYXJreUxheWVyMiB9O1xuaW1wb3J0IHsgRmllbGQsIFVJbnQ2NCwgbWF0cml4UHJvcCB9IGZyb20gJ3NuYXJreWpzJztcbmltcG9ydCB7IFNuYXJreVRlbnNvciB9IGZyb20gJy4vc25hcmt5VGVuc29yLmpzJztcbi8vIGF3YWl0IGlzUmVhZHk7XG4vLyBjcmVhdGUgYSBsYXllclxuY2xhc3MgU25hcmt5TGF5ZXIxIGV4dGVuZHMgU25hcmt5VGVuc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih3ZWlnaHRzLCBhY3RpdmF0aW9uID0gJ3JlbHUnLCAvLyBkZWZhdWx0IGFjdGl2YXRpb24gZnVuY3Rpb25cbiAgICBhbHBoYSA9IEZpZWxkKDEwKSAvLyBhbHJlYWQgc2NhbGVkIGJ5IDEwMDBcbiAgICApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gdGhpcy5zY2FsZV9mYWN0b3JfRmllbGQgPSBGaWVsZCgxMDAwMDAwMCk7XG4gICAgICAgIC8vIEFjdGl2YXRpb24gRnVuY3Rpb25cbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uID0gdGhpcy5hY3RpdmF0aW9uX3NlbGVjdGlvbihhY3RpdmF0aW9uKTtcbiAgICAgICAgLy8gU2V0IGFscGhhXG4gICAgICAgIC8vIHRoaXMuYWxwaGEgPSB0aGlzLm51bTJpbnQ2NShhbHBoYSk7XG4gICAgICAgIHRoaXMuYWxwaGEgPSBhbHBoYTtcbiAgICAgICAgLy8gV2VpZ2h0c1xuICAgICAgICB0aGlzLndlaWdodHMgPSB3ZWlnaHRzO1xuICAgIH1cbiAgICAvLyAvLyBEZXNjcmlwdGlvbjogICBQZXJmb3JtIGEgZG90IHByb2R1Y3QgZm9yIHR3byByYW5rIDIgdGVuc29ycyBvZiB0eXBlIEZpZWxkXG4gICAgLy8gLy8gSW5wdXQ6ICAgICAgICAgbTEgLSBSYW5rIDIgVGVuc29yIG9mIHR5cGUgRmllbGRcbiAgICAvLyAvLyAgICAgICAgICAgICAgICBtMiAtIFJhbmsgMiBUZW5zb3Igb2YgdHlwZSBGaWVsZFxuICAgIC8vIC8vIE91dHB1dDogICAgICAgIHkgLSBEb3QgcHJvZHVjdCBSYW5rIDIgVGVuc29yIG9mIHR5cGUgRmllbGRcbiAgICAvLyBkb3RfcHJvZHVjdF90MihtMTogQXJyYXk8RmllbGQ+W10sIG0yOiBBcnJheTxGaWVsZD5bXSk6IEFycmF5PEZpZWxkPltdIHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKCdpbiB0aGUgZG90IHByb2R1Y3QnKTtcbiAgICAvLyAgIC8vIFBlcmZvcm0gYSBkb3QgcHJvZHVjdCBvbiB0aGUgdHdvIHJhbmsgMiB0ZW5zb3JzXG4gICAgLy8gICBsZXQgeSA9IEFycmF5KCk7XG4gICAgLy8gICBsZXQgbTJfdCA9IHRoaXMudHJhbnNwb3NlKG0yKTtcbiAgICAvLyAgIC8vIGxldCBtMl90ID0gbTI7XG4gICAgLy8gICBmb3IgKGxldCBpID0gMDsgaSA8IG0xLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gICAgIGNvbnNvbGUubG9nKCdpbiB0aGUgZm9yIGxvb3AnLCBpKTtcbiAgICAvLyAgICAgbGV0IG1fYXJyYXkgPSBBcnJheSgpO1xuICAgIC8vICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG0yX3QubGVuZ3RoOyBqKyspIHtcbiAgICAvLyAgICAgICBjb25zb2xlLmxvZygnaW4gdGhlIGZvciBsb29wJywgaik7XG4gICAgLy8gICAgICAgbV9hcnJheVtqXSA9IHRoaXMuZG90X3Byb2R1Y3RfdDEobTFbaV0sIG0yX3Rbal0pO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHlbaV0gPSBtX2FycmF5O1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuIHk7XG4gICAgLy8gfVxuICAgIC8vIC8vIERlc2NyaXB0aW9uOiAgIFBlcmZvcm0gYSBkb3QgcHJvZHVjdCBmb3IgdHdvIHJhbmsgMSB0ZW5zb3JzIG9mIHR5cGUgRmllbGRcbiAgICAvLyAvLyBJbnB1dDogICAgICAgICBtMSAtIFJhbmsgMSBUZW5zb3Igb2YgdHlwZSBGaWVsZFxuICAgIC8vIC8vICAgICAgICAgICAgICAgIG0yIC0gUmFuayAxIFRlbnNvciBvZiB0eXBlIEZpZWxkXG4gICAgLy8gLy8gT3V0cHV0OiAgICAgICAgeSAtIERvdCBwcm9kdWN0IFJhbmsgMCBUZW5zb3Igb2YgdHlwZSBGaWVsZFxuICAgIC8vIGRvdF9wcm9kdWN0X3QxKHYxOiBBcnJheTxGaWVsZD4sIHYyOiBBcnJheTxGaWVsZD4pOiBGaWVsZCB7XG4gICAgLy8gICBsZXQgeSA9IEZpZWxkLnplcm87XG4gICAgLy8gICBjb25zb2xlLmFzc2VydChcbiAgICAvLyAgICAgdjEubGVuZ3RoID09PSB2Mi5sZW5ndGgsXG4gICAgLy8gICAgIFwidGVuc29yIGRpbWVuc2lvbnMgZG8gbm90IGZpdCwgY2FuJ3QgZG8gZG90X3Byb2R1Y3RfdDFcIlxuICAgIC8vICAgKTtcbiAgICAvLyAgIHYxLmZvckVhY2goXG4gICAgLy8gICAgICh2MV92YWx1ZSwgaSkgPT5cbiAgICAvLyAgICAgICAvLyAoeSA9IHkuYWRkKHYxX3ZhbHVlLm11bCh2MltpXSkuZGl2KHRoaXMuc2NhbGVfZmFjdG9yX0ZpZWxkKSkpXG4gICAgLy8gICAgICAgKHkgPSB5LmFkZCh2MV92YWx1ZS5tdWwodjJbaV0pKSlcbiAgICAvLyAgICk7XG4gICAgLy8gICByZXR1cm4geTtcbiAgICAvLyB9XG4gICAgLy8gLy8gRGVzY3JpcHRpb246ICAgVHJhbnNwb3NlIGEgcmFuayAyIHRlbnNvciBvZiB0eXBlIEZpZWxkXG4gICAgLy8gLy8gSW5wdXQ6ICAgICAgICAgeCAtIFJhbmsgMiBUZW5zb3Igb2YgdHlwZSBGaWVsZFxuICAgIC8vIC8vIE91dHB1dDogICAgICAgIHkgLSBUcmFuc3Bvc2VkIFJhbmsgMiBUZW5zb3Igb2YgdHlwZSBGaWVsZCBvZiB4XG4gICAgLy8gdHJhbnNwb3NlKHg6IEFycmF5PEZpZWxkPltdKTogQXJyYXk8RmllbGQ+W10ge1xuICAgIC8vICAgLy8gVHJhbnNwb3NlIHRoZSByYW5rIDIgdGVuc29yXG4gICAgLy8gICBsZXQgeSA9IEFycmF5KCk7XG4gICAgLy8gICBmb3IgKGxldCBpID0gMDsgaSA8IHhbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgbGV0IG1fYXJyYXkgPSBBcnJheSgpO1xuICAgIC8vICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHgubGVuZ3RoOyBqKyspIHtcbiAgICAvLyAgICAgICBtX2FycmF5W2pdID0geFtqXVtpXTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICB5W2ldID0gbV9hcnJheTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiB5O1xuICAgIC8vIH1cbiAgICAvLyBleHBfcGFydCh4OiBVSW50NjQsIHk6IG51bWJlciwgejogbnVtYmVyKTogVUludDY0IHtcbiAgICAvLyAgIC8vIFBvcnRpb24gb2YgdGhlIEV4cG90ZW50aWFsIENhbGN1bGF0aW9uXG4gICAgLy8gICAvLyAoeF55KS96XG4gICAgLy8gICBsZXQgcmVzdWx0ID0gVUludDY0LmZyb20oeCk7XG4gICAgLy8gICByZXN1bHQgPSByZXN1bHQuZGl2KFVJbnQ2NC5mcm9tKHopKTtcbiAgICAvLyAgIGZvciAobGV0IGkgPSAxOyBpIDwgeTsgaSsrKSB7XG4gICAgLy8gICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwoeCkuZGl2KFVJbnQ2NC5mcm9tKHRoaXMuc2NhbGVfZmFjdG9yX0ZpZWxkKSk7XG4gICAgLy8gICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwoVUludDY0LmZyb20oeCkpO1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuIHJlc3VsdDtcbiAgICAvLyB9XG4gICAgLy8gLy8gRGVzY3JpcHRpb246ICAgQ2FsY3VsYXRlIHRoZSBleHBvdGVudGlhbFxuICAgIC8vIC8vIElucHV0OiAgICAgICAgIFJhbmsgMCBUZW5zb3Igb2YgdHlwZSBGaWVsZCBmb3IgdGhlIHBvd2VyXG4gICAgLy8gLy8gT3V0cHV0OiAgICAgICAgUmFuayAwIFRlbnNvciBvZiB0eXBlIEZpZWxkIHJlc3VsdCBvZiBjYWxjdWxhdGlvblxuICAgIC8vIGV4cCh4OiBVSW50NjQpOiBVSW50NjQge1xuICAgIC8vICAgLy8gRXhwb3RlbnRpYWwgSW1wbGVtZW50YXRpb25cbiAgICAvLyAgIC8vIDEgKyB4ICsgKHheMikvMiArICh4XjMpLzYgKyAoeF40KS8yNCArICh4XjUpLzEyMCArICh4XjYpLzcyMCArICh4XjcpLzUwNDBcbiAgICAvLyAgIC8vIHJldHVybiB0aGlzLm51bTJGaWVsZCgxKVxuICAgIC8vICAgcmV0dXJuIFVJbnQ2NC5vbmVcbiAgICAvLyAgICAgLmFkZChVSW50NjQuZnJvbSh4KSlcbiAgICAvLyAgICAgLmFkZCh0aGlzLmV4cF9wYXJ0KHgsIDIsIDIpKVxuICAgIC8vICAgICAuYWRkKHRoaXMuZXhwX3BhcnQoeCwgMywgNikpXG4gICAgLy8gICAgIC5hZGQodGhpcy5leHBfcGFydCh4LCA0LCAyNCkpXG4gICAgLy8gICAgIC5hZGQodGhpcy5leHBfcGFydCh4LCA1LCAxMjApKVxuICAgIC8vICAgICAuYWRkKHRoaXMuZXhwX3BhcnQoeCwgNiwgNzIwKSlcbiAgICAvLyAgICAgLmFkZCh0aGlzLmV4cF9wYXJ0KHgsIDcsIDUwNDApKTtcbiAgICAvLyB9XG4gICAgY2FsbChpbnB1dCkge1xuICAgICAgICBjb25zb2xlLmxvZygnaW4gdGhlIGNhbGwgZnVuY3Rpb24nKTtcbiAgICAgICAgLy8gRXF1aXZhbGVudDogb3V0cHV0ID0gYWN0aXZhdGlvbiggZG90KCBpbnB1dCwgd2VpZ2h0ICkgKVxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0aW9uX3QyKHRoaXMuZG90X3Byb2R1Y3RfdDIoaW5wdXQsIHRoaXMud2VpZ2h0cykpO1xuICAgIH1cbiAgICAvLyBTZWxlY3QgQWN0aXZhdGlvbiBGdW5jdGlvblxuICAgIGFjdGl2YXRpb25fc2VsZWN0aW9uKGFjdGl2YXRpb24pIHtcbiAgICAgICAgLy8gU2VsZWN0IHRoZSBhY3RpdmF0aW9uIGZ1bmN0aW9uXG4gICAgICAgIGlmIChhY3RpdmF0aW9uID09ICdyZWx1Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsdV90MTtcbiAgICAgICAgfSAvLyBSZWxVIEFjdGl2YXRpb24gRnVuY3Rpb25cbiAgICAgICAgZWxzZSBpZiAoYWN0aXZhdGlvbiA9PSAncmVsdV9sZWFreScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbHVfbGVha3lfdDE7XG4gICAgICAgIH0gLy8gTGVha3kgUmVsVSBBY3RpdmF0aW9uIEZ1bmN0aW9uXG4gICAgICAgIGVsc2UgaWYgKGFjdGl2YXRpb24gPT0gJ3NvZnRtYXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb2Z0bWF4X3QxO1xuICAgICAgICB9IC8vIFNvZnRtYXggQWN0aXZhdGlvbiBGdW5jdGlvblxuICAgICAgICAvLyBlbHNlIGlmIChhY3RpdmF0aW9uID09ICd0YXlsZXInKSB7XG4gICAgICAgIC8vICAgcmV0dXJuIHRoaXMudGF5bGVyO1xuICAgICAgICAvLyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FjdGl2YXRpb24gRnVuY3Rpb24gTm90IFZhbGlkJyk7XG4gICAgICAgIH0gLy8gSW52YWxpZCBBY3RpdmF0aW9uIEZ1bmN0aW9uXG4gICAgfVxuICAgIC8vIEFjdGl2YXRpb25cbiAgICBhY3RpdmF0aW9uX3QyKHgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2luIHRoZSBhY3RpdmF0aW9uX3QyIGZ1bmN0aW9uJyk7XG4gICAgICAgIC8vIEFwcGx5aW5nIGFjdGl2YXRpb24gZnVuY3Rpb25zIGZvciBhIHJhbmsgMiB0ZW5zb3JcbiAgICAgICAgbGV0IHJlc3VsdCA9IEFycmF5KCk7XG4gICAgICAgIC8vIHguZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiAocmVzdWx0W2luZGV4XSA9IHRoaXMuYWN0aXZhdGlvbih2YWx1ZSkpKTtcbiAgICAgICAgeC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IChyZXN1bHRbaW5kZXhdID0gdGhpcy5yZWx1X3QxKHZhbHVlKSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBBY3RpdmF0aW9uIEZ1bmN0aW9ucyAoaW1wbGVtZW50ZWQgZm9yIHJhbmsgMSB0ZW5zb3JzKVxuICAgIHJlbHVfdDEoeCkge1xuICAgICAgICAvLyBSZWxVIGltcGxlbWVudGF0aW9uIGZvciBhbiBBcnJheVxuICAgICAgICAvLyBFcXVpdmFsZW50OiByZXN1bHQgPSBtYXgoIHgsIDAgKVxuICAgICAgICBsZXQgcmVzdWx0ID0gQXJyYXkoKTtcbiAgICAgICAgeC5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4gKHJlc3VsdFtpXSA9IHZhbHVlKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlbHVfbGVha3lfdDEoeCkge1xuICAgICAgICAvLyBMZWFreSBSZWxVIGltcGxlbWVudGF0aW9uIGZvciBhbiBBcnJheVxuICAgICAgICBsZXQgcmVzdWx0ID0gQXJyYXkoKTtcbiAgICAgICAgeC5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4gKHJlc3VsdFtpXSA9IHZhbHVlKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNvZnRtYXhfdDEoeCkge1xuICAgICAgICAvLyBTb2Z0bWF4IEltcGxlbWVudGF0aW9uIGZvciBhbiBBcnJheVxuICAgICAgICBjb25zb2xlLmxvZygnaW4gdGhlIHNvZnRtYXhfdDEgZnVuY3Rpb24nKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3ggYmVmb3JlIGV4cCBwYXJ0IGlzJywgeC50b1N0cmluZygpKTtcbiAgICAgICAgbGV0IHN1bSA9IFVJbnQ2NC56ZXJvO1xuICAgICAgICBsZXQgcmVzdWx0ID0gQXJyYXkoKTtcbiAgICAgICAgLy8gRXF1aXZhbGVudDogcmVzdWx0ID0geCAvICggeDEgKyAuLiArIHhuIClcbiAgICAgICAgY29uc29sZS5sb2coJ3ggYmVmb3JlIGV4cCBwYXJ0IGlzJywgeC50b1N0cmluZygpKTtcbiAgICAgICAgLy8gcHJldmVudGluZyBvdmVyZmxvd1xuICAgICAgICBsZXQgcmVkdWNlZF94ID0gQXJyYXkoKTtcbiAgICAgICAgeC5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4gKHJlZHVjZWRfeFtpXSA9IFVJbnQ2NC5mcm9tKHZhbHVlKS5kaXYoVUludDY0LmZyb20oMTAwMDAwMCkpKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCd4IGFmdGVyIG92ZXJmbG93IHByZXZlbnRpb24gaXMnLCByZWR1Y2VkX3gudG9TdHJpbmcoKSk7XG4gICAgICAgIHJlZHVjZWRfeC5mb3JFYWNoKCh2YWx1ZSkgPT4gY29uc29sZS5sb2codGhpcy5leHAodmFsdWUpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3ggYWZ0ZXIgZXhwIGlzJywgcmVkdWNlZF94LnRvU3RyaW5nKCkpO1xuICAgICAgICAvLyByZXN1bHQgcmV0dXJuZWQgYXMgcGVyY2VudGFnZVxuICAgICAgICByZWR1Y2VkX3guZm9yRWFjaCgodmFsdWUpID0+IChzdW0gPSBzdW0uYWRkKHRoaXMuZXhwKHZhbHVlKSkpKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3N1bSBpcycsIHN1bS50b1N0cmluZygpKTtcbiAgICAgICAgcmVkdWNlZF94LmZvckVhY2goKHZhbHVlLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgcXVvdGllbnRBbmRSZW1haW5kZXIgPSB0aGlzLmV4cCh2YWx1ZSkuZGl2TW9kKHN1bSk7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBxdW90aWVudEFuZFJlbWFpbmRlci5yZXN0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coJ3Jlc3VsdCBpcycsIHJlc3VsdC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBtYXRyaXhQcm9wKEZpZWxkLCA2NCwgMTApLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFNuYXJreUxheWVyMS5wcm90b3R5cGUsIFwid2VpZ2h0c1wiLCB2b2lkIDApO1xuY2xhc3MgU25hcmt5TGF5ZXIyIGV4dGVuZHMgU25hcmt5VGVuc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih3ZWlnaHRzLCBhY3RpdmF0aW9uID0gJ3JlbHUnLCAvLyBkZWZhdWx0IGFjdGl2YXRpb24gZnVuY3Rpb25cbiAgICBhbHBoYSA9IEZpZWxkKDEwKSAvLyBhbHJlYWQgc2NhbGVkIGJ5IDEwMDBcbiAgICApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gdGhpcy5zY2FsZV9mYWN0b3JfRmllbGQgPSBGaWVsZCgxMDAwMDAwMCk7XG4gICAgICAgIC8vIEFjdGl2YXRpb24gRnVuY3Rpb25cbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uID0gdGhpcy5hY3RpdmF0aW9uX3NlbGVjdGlvbihhY3RpdmF0aW9uKTtcbiAgICAgICAgLy8gU2V0IGFscGhhXG4gICAgICAgIC8vIHRoaXMuYWxwaGEgPSB0aGlzLm51bTJpbnQ2NShhbHBoYSk7XG4gICAgICAgIHRoaXMuYWxwaGEgPSBhbHBoYTtcbiAgICAgICAgLy8gV2VpZ2h0c1xuICAgICAgICB0aGlzLndlaWdodHMgPSB3ZWlnaHRzO1xuICAgIH1cbiAgICAvLyAvLyBEZXNjcmlwdGlvbjogICBQZXJmb3JtIGEgZG90IHByb2R1Y3QgZm9yIHR3byByYW5rIDIgdGVuc29ycyBvZiB0eXBlIEZpZWxkXG4gICAgLy8gLy8gSW5wdXQ6ICAgICAgICAgbTEgLSBSYW5rIDIgVGVuc29yIG9mIHR5cGUgRmllbGRcbiAgICAvLyAvLyAgICAgICAgICAgICAgICBtMiAtIFJhbmsgMiBUZW5zb3Igb2YgdHlwZSBGaWVsZFxuICAgIC8vIC8vIE91dHB1dDogICAgICAgIHkgLSBEb3QgcHJvZHVjdCBSYW5rIDIgVGVuc29yIG9mIHR5cGUgRmllbGRcbiAgICAvLyBkb3RfcHJvZHVjdF90MihtMTogQXJyYXk8RmllbGQ+W10sIG0yOiBBcnJheTxGaWVsZD5bXSk6IEFycmF5PEZpZWxkPltdIHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKCdpbiB0aGUgZG90IHByb2R1Y3QnKTtcbiAgICAvLyAgIC8vIFBlcmZvcm0gYSBkb3QgcHJvZHVjdCBvbiB0aGUgdHdvIHJhbmsgMiB0ZW5zb3JzXG4gICAgLy8gICBsZXQgeSA9IEFycmF5KCk7XG4gICAgLy8gICBsZXQgbTJfdCA9IHRoaXMudHJhbnNwb3NlKG0yKTtcbiAgICAvLyAgIC8vIGxldCBtMl90ID0gbTI7XG4gICAgLy8gICBmb3IgKGxldCBpID0gMDsgaSA8IG0xLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gICAgIGNvbnNvbGUubG9nKCdpbiB0aGUgZm9yIGxvb3AnLCBpKTtcbiAgICAvLyAgICAgbGV0IG1fYXJyYXkgPSBBcnJheSgpO1xuICAgIC8vICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG0yX3QubGVuZ3RoOyBqKyspIHtcbiAgICAvLyAgICAgICBjb25zb2xlLmxvZygnaW4gdGhlIGZvciBsb29wJywgaik7XG4gICAgLy8gICAgICAgbV9hcnJheVtqXSA9IHRoaXMuZG90X3Byb2R1Y3RfdDEobTFbaV0sIG0yX3Rbal0pO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHlbaV0gPSBtX2FycmF5O1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuIHk7XG4gICAgLy8gfVxuICAgIC8vIC8vIERlc2NyaXB0aW9uOiAgIFBlcmZvcm0gYSBkb3QgcHJvZHVjdCBmb3IgdHdvIHJhbmsgMSB0ZW5zb3JzIG9mIHR5cGUgRmllbGRcbiAgICAvLyAvLyBJbnB1dDogICAgICAgICBtMSAtIFJhbmsgMSBUZW5zb3Igb2YgdHlwZSBGaWVsZFxuICAgIC8vIC8vICAgICAgICAgICAgICAgIG0yIC0gUmFuayAxIFRlbnNvciBvZiB0eXBlIEZpZWxkXG4gICAgLy8gLy8gT3V0cHV0OiAgICAgICAgeSAtIERvdCBwcm9kdWN0IFJhbmsgMCBUZW5zb3Igb2YgdHlwZSBGaWVsZFxuICAgIC8vIGRvdF9wcm9kdWN0X3QxKHYxOiBBcnJheTxGaWVsZD4sIHYyOiBBcnJheTxGaWVsZD4pOiBGaWVsZCB7XG4gICAgLy8gICBsZXQgeSA9IEZpZWxkLnplcm87XG4gICAgLy8gICBjb25zb2xlLmFzc2VydChcbiAgICAvLyAgICAgdjEubGVuZ3RoID09PSB2Mi5sZW5ndGgsXG4gICAgLy8gICAgIFwidGVuc29yIGRpbWVuc2lvbnMgZG8gbm90IGZpdCwgY2FuJ3QgZG8gZG90X3Byb2R1Y3RfdDFcIlxuICAgIC8vICAgKTtcbiAgICAvLyAgIHYxLmZvckVhY2goXG4gICAgLy8gICAgICh2MV92YWx1ZSwgaSkgPT5cbiAgICAvLyAgICAgICAvLyAoeSA9IHkuYWRkKHYxX3ZhbHVlLm11bCh2MltpXSkuZGl2KHRoaXMuc2NhbGVfZmFjdG9yX0ZpZWxkKSkpXG4gICAgLy8gICAgICAgKHkgPSB5LmFkZCh2MV92YWx1ZS5tdWwodjJbaV0pKSlcbiAgICAvLyAgICk7XG4gICAgLy8gICByZXR1cm4geTtcbiAgICAvLyB9XG4gICAgLy8gLy8gRGVzY3JpcHRpb246ICAgVHJhbnNwb3NlIGEgcmFuayAyIHRlbnNvciBvZiB0eXBlIEZpZWxkXG4gICAgLy8gLy8gSW5wdXQ6ICAgICAgICAgeCAtIFJhbmsgMiBUZW5zb3Igb2YgdHlwZSBGaWVsZFxuICAgIC8vIC8vIE91dHB1dDogICAgICAgIHkgLSBUcmFuc3Bvc2VkIFJhbmsgMiBUZW5zb3Igb2YgdHlwZSBGaWVsZCBvZiB4XG4gICAgLy8gdHJhbnNwb3NlKHg6IEFycmF5PEZpZWxkPltdKTogQXJyYXk8RmllbGQ+W10ge1xuICAgIC8vICAgLy8gVHJhbnNwb3NlIHRoZSByYW5rIDIgdGVuc29yXG4gICAgLy8gICBsZXQgeSA9IEFycmF5KCk7XG4gICAgLy8gICBmb3IgKGxldCBpID0gMDsgaSA8IHhbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgbGV0IG1fYXJyYXkgPSBBcnJheSgpO1xuICAgIC8vICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHgubGVuZ3RoOyBqKyspIHtcbiAgICAvLyAgICAgICBtX2FycmF5W2pdID0geFtqXVtpXTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICB5W2ldID0gbV9hcnJheTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiB5O1xuICAgIC8vIH1cbiAgICAvLyBleHBfcGFydCh4OiBVSW50NjQsIHk6IG51bWJlciwgejogbnVtYmVyKTogVUludDY0IHtcbiAgICAvLyAgIC8vIFBvcnRpb24gb2YgdGhlIEV4cG90ZW50aWFsIENhbGN1bGF0aW9uXG4gICAgLy8gICAvLyAoeF55KS96XG4gICAgLy8gICBsZXQgcmVzdWx0ID0gVUludDY0LmZyb20oeCk7XG4gICAgLy8gICByZXN1bHQgPSByZXN1bHQuZGl2KFVJbnQ2NC5mcm9tKHopKTtcbiAgICAvLyAgIGZvciAobGV0IGkgPSAxOyBpIDwgeTsgaSsrKSB7XG4gICAgLy8gICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwoeCkuZGl2KFVJbnQ2NC5mcm9tKHRoaXMuc2NhbGVfZmFjdG9yX0ZpZWxkKSk7XG4gICAgLy8gICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwoVUludDY0LmZyb20oeCkpO1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuIHJlc3VsdDtcbiAgICAvLyB9XG4gICAgLy8gLy8gRGVzY3JpcHRpb246ICAgQ2FsY3VsYXRlIHRoZSBleHBvdGVudGlhbFxuICAgIC8vIC8vIElucHV0OiAgICAgICAgIFJhbmsgMCBUZW5zb3Igb2YgdHlwZSBGaWVsZCBmb3IgdGhlIHBvd2VyXG4gICAgLy8gLy8gT3V0cHV0OiAgICAgICAgUmFuayAwIFRlbnNvciBvZiB0eXBlIEZpZWxkIHJlc3VsdCBvZiBjYWxjdWxhdGlvblxuICAgIC8vIGV4cCh4OiBVSW50NjQpOiBVSW50NjQge1xuICAgIC8vICAgLy8gRXhwb3RlbnRpYWwgSW1wbGVtZW50YXRpb25cbiAgICAvLyAgIC8vIDEgKyB4ICsgKHheMikvMiArICh4XjMpLzYgKyAoeF40KS8yNCArICh4XjUpLzEyMCArICh4XjYpLzcyMCArICh4XjcpLzUwNDBcbiAgICAvLyAgIC8vIHJldHVybiB0aGlzLm51bTJGaWVsZCgxKVxuICAgIC8vICAgcmV0dXJuIFVJbnQ2NC5vbmVcbiAgICAvLyAgICAgLmFkZChVSW50NjQuZnJvbSh4KSlcbiAgICAvLyAgICAgLmFkZCh0aGlzLmV4cF9wYXJ0KHgsIDIsIDIpKVxuICAgIC8vICAgICAuYWRkKHRoaXMuZXhwX3BhcnQoeCwgMywgNikpXG4gICAgLy8gICAgIC5hZGQodGhpcy5leHBfcGFydCh4LCA0LCAyNCkpXG4gICAgLy8gICAgIC5hZGQodGhpcy5leHBfcGFydCh4LCA1LCAxMjApKVxuICAgIC8vICAgICAuYWRkKHRoaXMuZXhwX3BhcnQoeCwgNiwgNzIwKSlcbiAgICAvLyAgICAgLmFkZCh0aGlzLmV4cF9wYXJ0KHgsIDcsIDUwNDApKTtcbiAgICAvLyB9XG4gICAgY2FsbChpbnB1dCkge1xuICAgICAgICBjb25zb2xlLmxvZygnaW4gdGhlIGNhbGwgZnVuY3Rpb24nKTtcbiAgICAgICAgLy8gRXF1aXZhbGVudDogb3V0cHV0ID0gYWN0aXZhdGlvbiggZG90KCBpbnB1dCwgd2VpZ2h0ICkgKVxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0aW9uX3QyKHRoaXMuZG90X3Byb2R1Y3RfdDIoaW5wdXQsIHRoaXMud2VpZ2h0cykpO1xuICAgIH1cbiAgICAvLyBTZWxlY3QgQWN0aXZhdGlvbiBGdW5jdGlvblxuICAgIGFjdGl2YXRpb25fc2VsZWN0aW9uKGFjdGl2YXRpb24pIHtcbiAgICAgICAgLy8gU2VsZWN0IHRoZSBhY3RpdmF0aW9uIGZ1bmN0aW9uXG4gICAgICAgIGlmIChhY3RpdmF0aW9uID09ICdyZWx1Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsdV90MTtcbiAgICAgICAgfSAvLyBSZWxVIEFjdGl2YXRpb24gRnVuY3Rpb25cbiAgICAgICAgZWxzZSBpZiAoYWN0aXZhdGlvbiA9PSAncmVsdV9sZWFreScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbHVfbGVha3lfdDE7XG4gICAgICAgIH0gLy8gTGVha3kgUmVsVSBBY3RpdmF0aW9uIEZ1bmN0aW9uXG4gICAgICAgIGVsc2UgaWYgKGFjdGl2YXRpb24gPT0gJ3NvZnRtYXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb2Z0bWF4X3QxO1xuICAgICAgICB9IC8vIFNvZnRtYXggQWN0aXZhdGlvbiBGdW5jdGlvblxuICAgICAgICAvLyBlbHNlIGlmIChhY3RpdmF0aW9uID09ICd0YXlsZXInKSB7XG4gICAgICAgIC8vICAgcmV0dXJuIHRoaXMudGF5bGVyO1xuICAgICAgICAvLyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FjdGl2YXRpb24gRnVuY3Rpb24gTm90IFZhbGlkJyk7XG4gICAgICAgIH0gLy8gSW52YWxpZCBBY3RpdmF0aW9uIEZ1bmN0aW9uXG4gICAgfVxuICAgIC8vIEFjdGl2YXRpb25cbiAgICBhY3RpdmF0aW9uX3QyKHgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2luIHRoZSBhY3RpdmF0aW9uX3QyIGZ1bmN0aW9uJyk7XG4gICAgICAgIC8vIEFwcGx5aW5nIGFjdGl2YXRpb24gZnVuY3Rpb25zIGZvciBhIHJhbmsgMiB0ZW5zb3JcbiAgICAgICAgbGV0IHJlc3VsdCA9IEFycmF5KCk7XG4gICAgICAgIC8vIHguZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiAocmVzdWx0W2luZGV4XSA9IHRoaXMuYWN0aXZhdGlvbih2YWx1ZSkpKTtcbiAgICAgICAgeC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IChyZXN1bHRbaW5kZXhdID0gdGhpcy5yZWx1X3QxKHZhbHVlKSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBBY3RpdmF0aW9uIEZ1bmN0aW9ucyAoaW1wbGVtZW50ZWQgZm9yIHJhbmsgMSB0ZW5zb3JzKVxuICAgIHJlbHVfdDEoeCkge1xuICAgICAgICAvLyBSZWxVIGltcGxlbWVudGF0aW9uIGZvciBhbiBBcnJheVxuICAgICAgICAvLyBFcXVpdmFsZW50OiByZXN1bHQgPSBtYXgoIHgsIDAgKVxuICAgICAgICBsZXQgcmVzdWx0ID0gQXJyYXkoKTtcbiAgICAgICAgeC5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4gKHJlc3VsdFtpXSA9IHZhbHVlKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlbHVfbGVha3lfdDEoeCkge1xuICAgICAgICAvLyBMZWFreSBSZWxVIGltcGxlbWVudGF0aW9uIGZvciBhbiBBcnJheVxuICAgICAgICBsZXQgcmVzdWx0ID0gQXJyYXkoKTtcbiAgICAgICAgeC5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4gKHJlc3VsdFtpXSA9IHZhbHVlKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNvZnRtYXhfdDEoeCkge1xuICAgICAgICAvLyBTb2Z0bWF4IEltcGxlbWVudGF0aW9uIGZvciBhbiBBcnJheVxuICAgICAgICBjb25zb2xlLmxvZygnaW4gdGhlIHNvZnRtYXhfdDEgZnVuY3Rpb24nKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3ggYmVmb3JlIGV4cCBwYXJ0IGlzJywgeC50b1N0cmluZygpKTtcbiAgICAgICAgbGV0IHN1bSA9IFVJbnQ2NC56ZXJvO1xuICAgICAgICBsZXQgcmVzdWx0ID0gQXJyYXkoKTtcbiAgICAgICAgLy8gRXF1aXZhbGVudDogcmVzdWx0ID0geCAvICggeDEgKyAuLiArIHhuIClcbiAgICAgICAgY29uc29sZS5sb2coJ3ggYmVmb3JlIGV4cCBwYXJ0IGlzJywgeC50b1N0cmluZygpKTtcbiAgICAgICAgLy8gcHJldmVudGluZyBvdmVyZmxvd1xuICAgICAgICBsZXQgcmVkdWNlZF94ID0gQXJyYXkoKTtcbiAgICAgICAgeC5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4gKHJlZHVjZWRfeFtpXSA9IFVJbnQ2NC5mcm9tKHZhbHVlKS5kaXYoVUludDY0LmZyb20oMTAwMDAwMCkpKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCd4IGFmdGVyIG92ZXJmbG93IHByZXZlbnRpb24gaXMnLCByZWR1Y2VkX3gudG9TdHJpbmcoKSk7XG4gICAgICAgIHJlZHVjZWRfeC5mb3JFYWNoKCh2YWx1ZSkgPT4gY29uc29sZS5sb2codGhpcy5leHAodmFsdWUpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3ggYWZ0ZXIgZXhwIGlzJywgcmVkdWNlZF94LnRvU3RyaW5nKCkpO1xuICAgICAgICAvLyByZXN1bHQgcmV0dXJuZWQgYXMgcGVyY2VudGFnZVxuICAgICAgICByZWR1Y2VkX3guZm9yRWFjaCgodmFsdWUpID0+IChzdW0gPSBzdW0uYWRkKHRoaXMuZXhwKHZhbHVlKSkpKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3N1bSBpcycsIHN1bS50b1N0cmluZygpKTtcbiAgICAgICAgcmVkdWNlZF94LmZvckVhY2goKHZhbHVlLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgcXVvdGllbnRBbmRSZW1haW5kZXIgPSB0aGlzLmV4cCh2YWx1ZSkuZGl2TW9kKHN1bSk7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBxdW90aWVudEFuZFJlbWFpbmRlci5yZXN0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coJ3Jlc3VsdCBpcycsIHJlc3VsdC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBtYXRyaXhQcm9wKEZpZWxkLCAxMCwgMTApLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFNuYXJreUxheWVyMi5wcm90b3R5cGUsIFwid2VpZ2h0c1wiLCB2b2lkIDApO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c25hcmt5TGF5ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../contracts/build/src/snarkyLayer.js\n"));

/***/ }),

/***/ "../contracts/build/src/snarkyTensor.js":
/*!**********************************************!*\
  !*** ../contracts/build/src/snarkyTensor.js ***!
  \**********************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.a(__webpack_module__, async function (__webpack_handle_async_dependencies__, __webpack_async_result__) { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SnarkyTensor\": function() { return /* binding */ SnarkyTensor; }\n/* harmony export */ });\n/* harmony import */ var snarkyjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! snarkyjs */ \"./node_modules/snarkyjs/dist/web/index.js\");\n// Description: SnarkyTensor allows for the methods utilized for manipulating tensors\n// TODO: float to Field conversion is currently dependend on the Math library\n// therefore it cannot be considered a pure snarkyJS implementation and so it is not secure.\n\n\nawait snarkyjs__WEBPACK_IMPORTED_MODULE_0__.isReady;\nclass SnarkyTensor extends snarkyjs__WEBPACK_IMPORTED_MODULE_0__.CircuitValue {\n    constructor(power = (0,snarkyjs__WEBPACK_IMPORTED_MODULE_0__.Field)(10000000)) {\n        // Multiplier for representing decimals\n        // this.scale_factor = Math.pow(10, power);\n        // this.scale_factor = power;\n        super();\n        this.scale_factor_Field = power;\n    }\n    // Description:   Perform a dot product for two rank 2 tensors of type Field\n    // Input:         m1 - Rank 2 Tensor of type Field\n    //                m2 - Rank 2 Tensor of type Field\n    // Output:        y - Dot product Rank 2 Tensor of type Field\n    dot_product_t2(m1, m2) {\n        console.log('in the dot product');\n        // Perform a dot product on the two rank 2 tensors\n        let y = Array();\n        let m2_t = this.transpose(m2);\n        // let m2_t = m2;\n        for (let i = 0; i < m1.length; i++) {\n            console.log('in the for loop', i);\n            let m_array = Array();\n            for (let j = 0; j < m2_t.length; j++) {\n                console.log('in the for loop', j);\n                m_array[j] = this.dot_product_t1(m1[i], m2_t[j]);\n            }\n            y[i] = m_array;\n        }\n        return y;\n    }\n    // Description:   Perform a dot product for two rank 1 tensors of type Field\n    // Input:         m1 - Rank 1 Tensor of type Field\n    //                m2 - Rank 1 Tensor of type Field\n    // Output:        y - Dot product Rank 0 Tensor of type Field\n    dot_product_t1(v1, v2) {\n        let y = snarkyjs__WEBPACK_IMPORTED_MODULE_0__.Field.zero;\n        console.assert(v1.length === v2.length, \"tensor dimensions do not fit, can't do dot_product_t1\");\n        v1.forEach((v1_value, i) => \n        // (y = y.add(v1_value.mul(v2[i]).div(this.scale_factor_Field)))\n        (y = y.add(v1_value.mul(v2[i]))));\n        return y;\n    }\n    // Description:   Transpose a rank 2 tensor of type Field\n    // Input:         x - Rank 2 Tensor of type Field\n    // Output:        y - Transposed Rank 2 Tensor of type Field of x\n    transpose(x) {\n        // Transpose the rank 2 tensor\n        let y = Array();\n        for (let i = 0; i < x[0].length; i++) {\n            let m_array = Array();\n            for (let j = 0; j < x.length; j++) {\n                m_array[j] = x[j][i];\n            }\n            y[i] = m_array;\n        }\n        return y;\n    }\n    exp_part(x, y, z) {\n        // Portion of the Expotential Calculation\n        // (x^y)/z\n        let result = snarkyjs__WEBPACK_IMPORTED_MODULE_0__.UInt64.from(x);\n        result = result.div(snarkyjs__WEBPACK_IMPORTED_MODULE_0__.UInt64.from(z));\n        for (let i = 1; i < y; i++) {\n            result = result.mul(x).div(snarkyjs__WEBPACK_IMPORTED_MODULE_0__.UInt64.from(this.scale_factor_Field));\n            result = result.mul(snarkyjs__WEBPACK_IMPORTED_MODULE_0__.UInt64.from(x));\n        }\n        return result;\n    }\n    // Description:   Calculate the expotential\n    // Input:         Rank 0 Tensor of type Field for the power\n    // Output:        Rank 0 Tensor of type Field result of calculation\n    exp(x) {\n        // Expotential Implementation\n        // 1 + x + (x^2)/2 + (x^3)/6 + (x^4)/24 + (x^5)/120 + (x^6)/720 + (x^7)/5040\n        // return this.num2Field(1)\n        return snarkyjs__WEBPACK_IMPORTED_MODULE_0__.UInt64.one.add(snarkyjs__WEBPACK_IMPORTED_MODULE_0__.UInt64.from(x))\n            .add(this.exp_part(x, 2, 2))\n            .add(this.exp_part(x, 3, 6))\n            .add(this.exp_part(x, 4, 24))\n            .add(this.exp_part(x, 5, 120))\n            .add(this.exp_part(x, 6, 720))\n            .add(this.exp_part(x, 7, 5040));\n    }\n}\n//# sourceMappingURL=snarkyTensor.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29udHJhY3RzL2J1aWxkL3NyYy9zbmFya3lUZW5zb3IuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ3dCO0FBQ3lDO0FBQ2pFLE1BQU0sNkNBQU87QUFDYiwyQkFBMkIsa0RBQVk7QUFDdkMsd0JBQXdCLCtDQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaURBQVc7QUFDaEMsNEJBQTRCLGlEQUFXO0FBQ3ZDLHdCQUF3QixPQUFPO0FBQy9CLHVDQUF1QyxpREFBVztBQUNsRCxnQ0FBZ0MsaURBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9EQUNDLENBQUMsaURBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb250cmFjdHMvYnVpbGQvc3JjL3NuYXJreVRlbnNvci5qcz9mZGFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIERlc2NyaXB0aW9uOiBTbmFya3lUZW5zb3IgYWxsb3dzIGZvciB0aGUgbWV0aG9kcyB1dGlsaXplZCBmb3IgbWFuaXB1bGF0aW5nIHRlbnNvcnNcbi8vIFRPRE86IGZsb2F0IHRvIEZpZWxkIGNvbnZlcnNpb24gaXMgY3VycmVudGx5IGRlcGVuZGVuZCBvbiB0aGUgTWF0aCBsaWJyYXJ5XG4vLyB0aGVyZWZvcmUgaXQgY2Fubm90IGJlIGNvbnNpZGVyZWQgYSBwdXJlIHNuYXJreUpTIGltcGxlbWVudGF0aW9uIGFuZCBzbyBpdCBpcyBub3Qgc2VjdXJlLlxuZXhwb3J0IHsgU25hcmt5VGVuc29yIH07XG5pbXBvcnQgeyBGaWVsZCwgaXNSZWFkeSwgVUludDY0LCBDaXJjdWl0VmFsdWUsIH0gZnJvbSAnc25hcmt5anMnO1xuYXdhaXQgaXNSZWFkeTtcbmNsYXNzIFNuYXJreVRlbnNvciBleHRlbmRzIENpcmN1aXRWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IocG93ZXIgPSBGaWVsZCgxMDAwMDAwMCkpIHtcbiAgICAgICAgLy8gTXVsdGlwbGllciBmb3IgcmVwcmVzZW50aW5nIGRlY2ltYWxzXG4gICAgICAgIC8vIHRoaXMuc2NhbGVfZmFjdG9yID0gTWF0aC5wb3coMTAsIHBvd2VyKTtcbiAgICAgICAgLy8gdGhpcy5zY2FsZV9mYWN0b3IgPSBwb3dlcjtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zY2FsZV9mYWN0b3JfRmllbGQgPSBwb3dlcjtcbiAgICB9XG4gICAgLy8gRGVzY3JpcHRpb246ICAgUGVyZm9ybSBhIGRvdCBwcm9kdWN0IGZvciB0d28gcmFuayAyIHRlbnNvcnMgb2YgdHlwZSBGaWVsZFxuICAgIC8vIElucHV0OiAgICAgICAgIG0xIC0gUmFuayAyIFRlbnNvciBvZiB0eXBlIEZpZWxkXG4gICAgLy8gICAgICAgICAgICAgICAgbTIgLSBSYW5rIDIgVGVuc29yIG9mIHR5cGUgRmllbGRcbiAgICAvLyBPdXRwdXQ6ICAgICAgICB5IC0gRG90IHByb2R1Y3QgUmFuayAyIFRlbnNvciBvZiB0eXBlIEZpZWxkXG4gICAgZG90X3Byb2R1Y3RfdDIobTEsIG0yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdpbiB0aGUgZG90IHByb2R1Y3QnKTtcbiAgICAgICAgLy8gUGVyZm9ybSBhIGRvdCBwcm9kdWN0IG9uIHRoZSB0d28gcmFuayAyIHRlbnNvcnNcbiAgICAgICAgbGV0IHkgPSBBcnJheSgpO1xuICAgICAgICBsZXQgbTJfdCA9IHRoaXMudHJhbnNwb3NlKG0yKTtcbiAgICAgICAgLy8gbGV0IG0yX3QgPSBtMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2luIHRoZSBmb3IgbG9vcCcsIGkpO1xuICAgICAgICAgICAgbGV0IG1fYXJyYXkgPSBBcnJheSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtMl90Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2luIHRoZSBmb3IgbG9vcCcsIGopO1xuICAgICAgICAgICAgICAgIG1fYXJyYXlbal0gPSB0aGlzLmRvdF9wcm9kdWN0X3QxKG0xW2ldLCBtMl90W2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlbaV0gPSBtX2FycmF5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgICAvLyBEZXNjcmlwdGlvbjogICBQZXJmb3JtIGEgZG90IHByb2R1Y3QgZm9yIHR3byByYW5rIDEgdGVuc29ycyBvZiB0eXBlIEZpZWxkXG4gICAgLy8gSW5wdXQ6ICAgICAgICAgbTEgLSBSYW5rIDEgVGVuc29yIG9mIHR5cGUgRmllbGRcbiAgICAvLyAgICAgICAgICAgICAgICBtMiAtIFJhbmsgMSBUZW5zb3Igb2YgdHlwZSBGaWVsZFxuICAgIC8vIE91dHB1dDogICAgICAgIHkgLSBEb3QgcHJvZHVjdCBSYW5rIDAgVGVuc29yIG9mIHR5cGUgRmllbGRcbiAgICBkb3RfcHJvZHVjdF90MSh2MSwgdjIpIHtcbiAgICAgICAgbGV0IHkgPSBGaWVsZC56ZXJvO1xuICAgICAgICBjb25zb2xlLmFzc2VydCh2MS5sZW5ndGggPT09IHYyLmxlbmd0aCwgXCJ0ZW5zb3IgZGltZW5zaW9ucyBkbyBub3QgZml0LCBjYW4ndCBkbyBkb3RfcHJvZHVjdF90MVwiKTtcbiAgICAgICAgdjEuZm9yRWFjaCgodjFfdmFsdWUsIGkpID0+IFxuICAgICAgICAvLyAoeSA9IHkuYWRkKHYxX3ZhbHVlLm11bCh2MltpXSkuZGl2KHRoaXMuc2NhbGVfZmFjdG9yX0ZpZWxkKSkpXG4gICAgICAgICh5ID0geS5hZGQodjFfdmFsdWUubXVsKHYyW2ldKSkpKTtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfVxuICAgIC8vIERlc2NyaXB0aW9uOiAgIFRyYW5zcG9zZSBhIHJhbmsgMiB0ZW5zb3Igb2YgdHlwZSBGaWVsZFxuICAgIC8vIElucHV0OiAgICAgICAgIHggLSBSYW5rIDIgVGVuc29yIG9mIHR5cGUgRmllbGRcbiAgICAvLyBPdXRwdXQ6ICAgICAgICB5IC0gVHJhbnNwb3NlZCBSYW5rIDIgVGVuc29yIG9mIHR5cGUgRmllbGQgb2YgeFxuICAgIHRyYW5zcG9zZSh4KSB7XG4gICAgICAgIC8vIFRyYW5zcG9zZSB0aGUgcmFuayAyIHRlbnNvclxuICAgICAgICBsZXQgeSA9IEFycmF5KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeFswXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1fYXJyYXkgPSBBcnJheSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB4Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbV9hcnJheVtqXSA9IHhbal1baV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5W2ldID0gbV9hcnJheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9XG4gICAgZXhwX3BhcnQoeCwgeSwgeikge1xuICAgICAgICAvLyBQb3J0aW9uIG9mIHRoZSBFeHBvdGVudGlhbCBDYWxjdWxhdGlvblxuICAgICAgICAvLyAoeF55KS96XG4gICAgICAgIGxldCByZXN1bHQgPSBVSW50NjQuZnJvbSh4KTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRpdihVSW50NjQuZnJvbSh6KSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgeTsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHgpLmRpdihVSW50NjQuZnJvbSh0aGlzLnNjYWxlX2ZhY3Rvcl9GaWVsZCkpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChVSW50NjQuZnJvbSh4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRGVzY3JpcHRpb246ICAgQ2FsY3VsYXRlIHRoZSBleHBvdGVudGlhbFxuICAgIC8vIElucHV0OiAgICAgICAgIFJhbmsgMCBUZW5zb3Igb2YgdHlwZSBGaWVsZCBmb3IgdGhlIHBvd2VyXG4gICAgLy8gT3V0cHV0OiAgICAgICAgUmFuayAwIFRlbnNvciBvZiB0eXBlIEZpZWxkIHJlc3VsdCBvZiBjYWxjdWxhdGlvblxuICAgIGV4cCh4KSB7XG4gICAgICAgIC8vIEV4cG90ZW50aWFsIEltcGxlbWVudGF0aW9uXG4gICAgICAgIC8vIDEgKyB4ICsgKHheMikvMiArICh4XjMpLzYgKyAoeF40KS8yNCArICh4XjUpLzEyMCArICh4XjYpLzcyMCArICh4XjcpLzUwNDBcbiAgICAgICAgLy8gcmV0dXJuIHRoaXMubnVtMkZpZWxkKDEpXG4gICAgICAgIHJldHVybiBVSW50NjQub25lXG4gICAgICAgICAgICAuYWRkKFVJbnQ2NC5mcm9tKHgpKVxuICAgICAgICAgICAgLmFkZCh0aGlzLmV4cF9wYXJ0KHgsIDIsIDIpKVxuICAgICAgICAgICAgLmFkZCh0aGlzLmV4cF9wYXJ0KHgsIDMsIDYpKVxuICAgICAgICAgICAgLmFkZCh0aGlzLmV4cF9wYXJ0KHgsIDQsIDI0KSlcbiAgICAgICAgICAgIC5hZGQodGhpcy5leHBfcGFydCh4LCA1LCAxMjApKVxuICAgICAgICAgICAgLmFkZCh0aGlzLmV4cF9wYXJ0KHgsIDYsIDcyMCkpXG4gICAgICAgICAgICAuYWRkKHRoaXMuZXhwX3BhcnQoeCwgNywgNTA0MCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNuYXJreVRlbnNvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../contracts/build/src/snarkyTensor.js\n"));

/***/ })

}]);